from datetime import datetime, timezone
import json
import pandas as pd

from strategy.utils_hashing import hash_dataframe
from trading_analysis.db import get_first_candle_from_db, load_ohlcv_from_db, save_model_run
from trading_analysis.indicators import calculate_indicators_cached
from trading_analysis.risk import calculate_inverse_balance_risk
from trading_analysis.signals import generate_signals, generate_signals_cached
from trading_analysis.backtest import run_backtest
from trading_analysis.charts import plot_backtest_progress

from strategy.objective import estimate_window_size_from_params, optimize_with_validation
from strategy.search_space import search_space
from trading_analysis.utils import prepare_params_for_logging, sanitize_params, split_train_val

from uuid import uuid4

verbose = False

def initialize_test(symbol: str, interval: str = "30") -> dict:
    """
    –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ—Ç –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –¥–ª—è walk-forward —Ç–µ—Å—Ç–∞.
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ª–æ–≤–∞—Ä—å —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏, –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–º–∏ –¥–ª—è –æ—Å–Ω–æ–≤–Ω–æ–≥–æ —Ü–∏–∫–ª–∞.
    """
    step_candles = int(24 * 60 / int(interval))
    ms_per_candle = int(interval) * 60_000
    last_candle = get_first_candle_from_db(symbol, interval)
    first_ts = int(last_candle.timestamp.timestamp() * 1000)
    now_ts = int(datetime.now(timezone.utc).timestamp() * 1000)

    return {
        "symbol": symbol,
        "interval": interval,
        "window_size": 1000,
        "step_candles": step_candles,
        "ms_per_candle": ms_per_candle,
        "first_ts": first_ts,
        "now_ts": now_ts,
        "total_pnl": 0.0,
        "days_elapsed": 0,
        "trade_log": [],
        "initial_balance": 1000.0,
        "balance": 1000.0,
        "best_params": None,
        "win_streak": 0,
        "risk_history": [],
        "search_space": search_space,
        "open_position": None,
        "session_uuid": str(uuid4())
    }

def load_initial_train_data(symbol: str, window_size: int, start_timestamp: int, interval: str):
    """
    –ó–∞–≥—Ä—É–∂–∞–µ—Ç –Ω–∞—á–∞–ª—å–Ω—ã–µ –æ–±—É—á–∞—é—â–∏–µ –¥–∞–Ω–Ω—ã–µ –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø–æ —Å–∏–º–≤–æ–ª—É.

    :param symbol: –ù–∞–∑–≤–∞–Ω–∏–µ –º–æ–Ω–µ—Ç—ã, –Ω–∞–ø—Ä–∏–º–µ—Ä 'BTCUSDT'
    :param window_size: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–≤–µ—á–µ–π –≤ –æ–±—É—á–∞—é—â–µ–º –æ–∫–Ω–µ
    :param start_timestamp: –ú–µ—Ç–∫–∞ –≤—Ä–µ–º–µ–Ω–∏ –Ω–∞—á–∞–ª–∞ (–≤ –º–∏–ª–ª–∏—Å–µ–∫—É–Ω–¥–∞—Ö)
    :return: DataFrame —Å –¥–∞–Ω–Ω—ã–º–∏
    """
    df = load_ohlcv_from_db(
        symbol=symbol,
        limit=window_size,
        start_timestamp=start_timestamp,
        interval=interval
    )
    return df

def is_end_of_data(test_end_ts: int) -> bool:
    """
    –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –¥–æ—Å—Ç–∏–≥–ª–∏ –ª–∏ –∫–æ–Ω—Ü–∞ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö.

    :param test_end_ts: –ö–æ–Ω–µ—Ü —Ç–µ—Å—Ç–æ–≤–æ–≥–æ –æ–∫–Ω–∞ –≤ –º–∏–ª–ª–∏—Å–µ–∫—É–Ω–¥–∞—Ö
    :return: True, –µ—Å–ª–∏ –±–æ–ª—å—à–µ –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
    """
    now_ts = int(datetime.now(timezone.utc).timestamp() * 1000)
    
    return test_end_ts > now_ts

def calculate_test_range(df_train, ms_per_candle, step_candles):
    """
    –í—ã—á–∏—Å–ª—è–µ—Ç –Ω–∞—á–∞–ª–æ –∏ –∫–æ–Ω–µ—Ü —Ç–µ—Å—Ç–æ–≤–æ–≥–æ –æ–∫–Ω–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ df_train.

    :param df_train: DataFrame —Å –∏—Å—Ç–æ—Ä–∏–µ–π –¥–ª—è –æ–±—É—á–µ–Ω–∏—è
    :param ms_per_candle: –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –æ–¥–Ω–æ–π —Å–≤–µ—á–∏ –≤ –º–∏–ª–ª–∏—Å–µ–∫—É–Ω–¥–∞—Ö
    :param step_candles: –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–≤–µ—á–µ–π –≤ —Ç–µ—Å—Ç–æ–≤–æ–º –æ–∫–Ω–µ
    :return: (test_start_ts, test_end_ts) ‚Äî –≤—Ä–µ–º–µ–Ω–Ω—ã–µ –º–µ—Ç–∫–∏ –Ω–∞—á–∞–ª–∞ –∏ –∫–æ–Ω—Ü–∞ —Ç–µ—Å—Ç–∞
    """
    last_ts_train = int(df_train.index[-1].timestamp() * 1000)
    test_start_ts = last_ts_train + ms_per_candle
    test_end_ts = test_start_ts + step_candles * ms_per_candle

    return test_start_ts, test_end_ts

def load_test_window_from_db(symbol: str, interval: str, test_range: tuple) -> pd.DataFrame:
    """
    –ó–∞–≥—Ä—É–∂–∞–µ—Ç —Ç–µ—Å—Ç–æ–≤–æ–µ –æ–∫–Ω–æ —Å–≤–µ—á–µ–π –∏–∑ –ª–æ–∫–∞–ª—å–Ω–æ–π –ë–î.

    :param symbol: —Ç–∏–∫–µ—Ä, –Ω–∞–ø—Ä–∏–º–µ—Ä "PRIMEUSDT"
    :param interval: —Å—Ç—Ä–æ–∫–∞ —Å –∏–Ω—Ç–µ—Ä–≤–∞–ª–æ–º, –Ω–∞–ø—Ä–∏–º–µ—Ä "30"
    :param test_range: –∫–æ—Ä—Ç–µ–∂ (start_timestamp_ms, end_timestamp_ms)
    :return: DataFrame —Å–æ —Å–≤–µ—á–∞–º–∏ –∑–∞ —É–∫–∞–∑–∞–Ω–Ω—ã–π –¥–∏–∞–ø–∞–∑–æ–Ω
    """
    start_ts, end_ts = test_range
    df = load_ohlcv_from_db(symbol, interval=interval, start_timestamp=start_ts, end_timestamp=end_ts)

    if df.empty:
        print("‚ö† –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –∏–∑ –ë–î –¥–ª—è —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ —Ç–µ—Å—Ç–æ–≤–æ–≥–æ –¥–∏–∞–ø–∞–∑–æ–Ω–∞.")
        return None

    return df

def prepare_test_data(df_train: pd.DataFrame, df_test: pd.DataFrame, best_params: dict) -> pd.DataFrame:
    """
    –û–±—ä–µ–¥–∏–Ω—è–µ—Ç —Ç—Ä–µ–Ω–∏—Ä–æ–≤–æ—á–Ω—ã–µ –∏ —Ç–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ, –ø—Ä–∏–º–µ–Ω—è–µ—Ç –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã –∏ —Å–∏–≥–Ω–∞–ª—ã,
    –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø–æ–¥–≥–æ—Ç–æ–≤–ª–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ —Ç–æ–ª—å–∫–æ –¥–ª—è —Ç–µ—Å—Ç–æ–≤–æ–≥–æ –æ–∫–Ω–∞.
    """
    df_full = pd.concat([df_train, df_test])
    df_full = df_full[~df_full.index.duplicated(keep="last")]  # üí° FIX HERE

    sanitized_params = sanitize_params(best_params)

    df_hash = hash_dataframe(df_full)
    params_serialized = json.dumps(sanitized_params, sort_keys=True)

    df_full = calculate_indicators_cached(df_hash, df_full, sanitized_params)
    df_full = generate_signals_cached(df_full, params_serialized)

    return df_full.iloc[-len(df_test):]


def run_evaluation(df_test_prepared, symbol: str, current_balance: float, risk_pct: float, open_position: dict = None) -> tuple:
    """
    –ü—Ä–æ–≤–æ–¥–∏—Ç –±—ç–∫—Ç–µ—Å—Ç –Ω–∞ —Ç–µ—Å—Ç–æ–≤–æ–º –æ–∫–Ω–µ –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç –∏ –æ–±–Ω–æ–≤–ª—ë–Ω–Ω—ã–π –±–∞–ª–∞–Ω—Å.

    :param df_test_prepared: DataFrame —Å —Ç–µ—Å—Ç–æ–≤—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏ –∏ —Å–∏–≥–Ω–∞–ª–∞–º–∏
    :param symbol: —Ç–∏–∫–µ—Ä —Å–∏–º–≤–æ–ª–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, "PRIMEUSDT")
    :param current_balance: —Ç–µ–∫—É—â–∏–π –±–∞–ª–∞–Ω—Å –Ω–∞ –º–æ–º–µ–Ω—Ç –≤—Ö–æ–¥–∞ –≤ –ø–µ—Ä–∏–æ–¥
    :param risk_pct: —Ä–∏—Å–∫ –Ω–∞ —Å–¥–µ–ª–∫—É –≤ –¥–æ–ª—è—Ö (–Ω–∞–ø—Ä–∏–º–µ—Ä, 0.05 = 5%)
    :return: (—Ä–µ–∑—É–ª—å—Ç–∞—Ç –±—ç–∫—Ç–µ—Å—Ç–∞, –Ω–æ–≤—ã–π –±–∞–ª–∞–Ω—Å)
    """
    result, final_state = run_backtest(
        df_test_prepared,
        symbol=symbol,
        report=True,
        finalize=True,
        initial_balance=current_balance,
        leverage=1,
        risk_pct=risk_pct,
        open_position=open_position
    )

    if final_state["position_type"]:
        new_open_position = {
            "position_type": final_state["position_type"],
            "entry_price": final_state["entry_price"],
            "position_size": final_state["position"],
            "trades": final_state["trades"]
        }
    else:
        new_open_position = None

    new_balance = current_balance + result["pnl"]
    return result, new_balance, new_open_position

def update_tracking(config: dict, interval, result: dict, df_test, df_test_prepared, triggered_restart):
    """
    –û–±–Ω–æ–≤–ª—è–µ—Ç –∂—É—Ä–Ω–∞–ª —Ç—Ä–µ–π–¥–æ–≤, —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –º–æ–¥–µ–ª–∏ –∏ –º–µ—Ç—Ä–∏–∫–∏.

    :param config: –∫–æ–Ω—Ñ–∏–≥ —Å–ª–æ–≤–∞—Ä—å —Å–æ –≤—Å–µ–º —Ç–µ–∫—É—â–∏–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ–º
    :param result: —Ä–µ–∑—É–ª—å—Ç–∞—Ç –±—ç–∫—Ç–µ—Å—Ç–∞
    :param df_test: –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π DataFrame —Ç–µ—Å—Ç–∞ (–±–µ–∑ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤)
    :param df_test_prepared: –ø–æ–¥–≥–æ—Ç–æ–≤–ª–µ–Ω–Ω—ã–π DataFrame —Ç–µ—Å—Ç–∞ (—Å –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞–º–∏)
    """
    trade_log = config.get("trade_log", [])
    days_elapsed = config.get("days_elapsed", 0) + 1
    test_date = df_test_prepared.index[0].to_pydatetime()

    # –û–±–Ω–æ–≤–ª—è–µ–º —Ç—Ä–µ–π–¥–ª–æ–≥
    trade_log.append({
        "date": test_date.strftime("%Y-%m-%d"),
        "pnl": result["pnl"]
    })

    # –ö–æ–º–ø–∞–∫—Ç–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
    log_entry = {
        "symbol": config["symbol"],
        "interval": interval,
        "date": test_date,
        "params": prepare_params_for_logging(config["best_params"], config),
        "loss": -result["winrate"],
        "pnl": result["pnl"],
        "total_trades": result["total_trades"],
        "winrate": result["winrate"],
        "risk_pct": config["risk_pct"],
        "retrained": result.get("pnl", 0) <= 0,
        "triggered_restart": triggered_restart,
        "session_uuid": config.get("session_uuid"),
        "balance": config["balance"],
        "best_params": config["best_params"],
        "trades": result.get("trades", [])
    }

    save_model_run(**log_entry)

    config["trade_log"] = trade_log
    config["days_elapsed"] = days_elapsed


def update_training_window(df_train, df_test, step_candles):
    """
    –û–±–Ω–æ–≤–ª—è–µ—Ç –æ–±—É—á–∞—é—â–µ–µ –æ–∫–Ω–æ, –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É—è –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–µ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π —Å df_test.
    """
    print("üß™ –¢–µ–∫—É—â–∏–π –∫–æ–Ω–µ—Ü df_train:", df_train.index[-1])
    print("üß™ –ù–∞—á–∞–ª–æ df_test:", df_test.index[0])

    base_cols = ["open", "high", "low", "close", "volume"]
    df_test_clean = df_test[base_cols]

    # –£–¥–∞–ª—è–µ–º –≤—Å–µ —Å—Ç—Ä–æ–∫–∏ –≤ df_train, –∫–æ—Ç–æ—Ä—ã–µ –ø–µ—Ä–µ–∫—Ä—ã–≤–∞—é—Ç—Å—è –ø–æ –≤—Ä–µ–º–µ–Ω–∏ —Å df_test
    df_train_filtered = df_train[df_train.index < df_test.index[0]]

    df_train_updated = pd.concat([df_train_filtered, df_test_clean])

    return df_train_updated


def finalize_walkforward(config):
    """
    –ó–∞–≤–µ—Ä—à–∞–µ—Ç walk-forward —Ç–µ—Å—Ç:
    - —Å—Ç—Ä–æ–∏—Ç —Ñ–∏–Ω–∞–ª—å–Ω—ã–π –≥—Ä–∞—Ñ–∏–∫ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞;
    - —Ä–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç –∏—Ç–æ–≥–æ–≤—É—é –¥–æ—Ö–æ–¥–Ω–æ—Å—Ç—å –∏ APR;
    - –≤—ã–≤–æ–¥–∏—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ —Ä–∏—Å–∫—É.
    """
    trade_log = config["trade_log"]
    initial_balance = config["initial_balance"]
    balance = config["balance"]
    days_elapsed = config["days_elapsed"]
    risk_history = config["risk_history"]
    symbol = config["symbol"]

    if not trade_log:
        print("‚ùó –ù–µ—Ç —Å–¥–µ–ª–æ–∫ ‚Äî –Ω–µ—Ç –≥—Ä–∞—Ñ–∏–∫–∞ –∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏.")
        return

    plot_backtest_progress(trade_log, title=f"–ü—Ä–æ–≥—Ä–µ—Å—Å —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –ø–æ {symbol}")

    total_pnl = balance - initial_balance
    apr = ((balance / initial_balance) ** (365 / days_elapsed) - 1) * 100 if days_elapsed > 0 else 0

    print(f"\nüìä –ò—Ç–æ–≥–æ–≤–∞—è –¥–æ—Ö–æ–¥–Ω–æ—Å—Ç—å: {total_pnl:.2f} | APR: {apr:.2f}% –∑–∞ {days_elapsed} –¥–Ω–µ–π")

    if risk_history:
        print("\nüìà –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ —Ä–∏—Å–∫—É:")
        print(f"- –°—Ä–µ–¥–Ω–∏–π —Ä–∏—Å–∫: {sum(risk_history) / len(risk_history):.3f}")
        print(f"- –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∏—Å–∫: {max(risk_history):.3f}")
        print(f"- –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —Ä–∏—Å–∫: {min(risk_history):.3f}")

def get_next_test_window(df_train, config, symbol, interval):
    test_range = calculate_test_range(df_train, config["ms_per_candle"], config["step_candles"])
    test_end_ts = test_range[1]
    if is_end_of_data(test_end_ts):
        return test_range, None

    df_test = load_test_window_from_db(symbol, interval, test_range)
    if df_test is None or df_test.empty:
        print("‚ö† –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Ç–µ—Å—Ç–æ–≤—ã—Ö –¥–∞–Ω–Ω—ã—Ö –≤ –ë–î.")
        return test_range, None

    return test_range, df_test

def initialize_best_params(config, df_train_raw, df_val_raw):
    df_full = pd.concat([df_train_raw, df_val_raw])
    df_hash = hash_dataframe(df_full)
    dummy_params = {
        "use_atr_filter": False,
        "use_trend_filter": False,
        "use_ema200_down_filter": False,
        "long_score_threshold": 1,
        "short_score_threshold": 1,
    }

    df_full = calculate_indicators_cached(df_hash, df_full, dummy_params)
    df_full = generate_signals(df_full, dummy_params)

    if verbose:
        print("long_entry class distribution:")
        print(df_full["long_entry"].value_counts())

    best_params, sharpe_train, sharpe_val = optimize_with_validation(
        df_train_raw, df_val_raw, config["symbol"], search_space,
    )

    if not best_params:
        # üëá –†–∞—Å—à–∏—Ä—è–µ–º –≤—Ä–µ–º–µ–Ω–Ω–æ –æ–∫–Ω–æ, –µ—Å–ª–∏ —Å—Ç—Ä–∞—Ç–µ–≥–∏—è –Ω–µ –Ω–∞—à–ª–∞—Å—å
        if config["window_size"] < 1500:  # –æ–≥—Ä–∞–Ω–∏—á–∏–º —Ä–∞–∑—É–º–Ω–æ–π –≤–µ—Ä—Ö–Ω–µ–π –≥—Ä–∞–Ω–∏—Ü–µ–π
            config["window_size"] += 500
            print(f"‚ö† –°—Ç—Ä–∞—Ç–µ–≥–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ ‚Äî —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º window_size –¥–æ {config['window_size']} –∏ –ø–æ–≤—Ç–æ—Ä—è–µ–º –ø–æ–ø—ã—Ç–∫—É.")
        else:
            print("‚õî –î–æ—Å—Ç–∏–≥–Ω—É—Ç –ø—Ä–µ–¥–µ–ª window_size ‚Äî –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –¥–µ–Ω—å.")
            return False
        return None  # üîÅ —Å–∏–≥–Ω–∞–ª –Ω–∞ –ø–æ–≤—Ç–æ—Ä —Å –Ω–æ–≤—ã–º –æ–∫–Ω–æ–º
    
    config.update({
        "best_params": best_params,
        "sharpe_train": sharpe_train,
        "sharpe_val": sharpe_val
    })
    return True

def reoptimize_strategy(config, df_train_raw, df_val_raw, symbol):
    print("üîÅ –ü–µ—Ä–µ–æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –∏–∑-–∑–∞ —Å–µ—Ä–∏–∏ —É–±—ã—Ç–æ—á–Ω—ã—Ö –¥–Ω–µ–π.")
    best_params, sharpe_train, sharpe_val = optimize_with_validation(
        df_train_raw, df_val_raw, symbol, search_space,
    )

    if not best_params:
        print("‚ö† –ü–µ—Ä–µ–æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –Ω–µ –¥–∞–ª–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ ‚Äî best_params —Å–±—Ä–æ—à–µ–Ω—ã.")
        config["best_params"] = None
    else:
        config.update({
            "best_params": best_params,
            "sharpe_train": sharpe_train,
            "sharpe_val": sharpe_val
        })

def should_trigger_restart(result, config) -> bool:
    if result["final_balance"] < config["initial_balance"] * 0.9:
        return True

    if result["total_trades"] == 0:
        config["no_trade_windows"] = config.get("no_trade_windows", 0) + 1
        if config["no_trade_windows"] >= 2:
            return True
    else:
        config["no_trade_windows"] = 0  # —Å–±—Ä–æ—Å, –µ—Å–ª–∏ —Å–¥–µ–ª–∫–∏ –ø–æ—è–≤–∏–ª–∏—Å—å

    if result["winrate"] < 0.4:
        return True

    return False

def walk_forward_test(symbol="PRIMEUSDT", interval="30"):
    config = initialize_test(symbol, interval)
    df_train = load_initial_train_data(
        symbol=symbol,
        window_size=config["window_size"],
        start_timestamp=config["first_ts"],
        interval=interval,
    )

    while True:
        test_range, df_test = get_next_test_window(df_train, config, symbol, interval)
        if df_test is None:
            break

        df_train_raw, df_val_raw = split_train_val(df_train)

        if not config.get("best_params"):
            while True:
                success = initialize_best_params(config, df_train_raw, df_val_raw)

                if success is True:
                    break  # –£—Å–ø–µ—à–Ω–æ
                elif success is False:
                    df_train = update_training_window(df_train, df_test, config["step_candles"])

                    # üí° –ï—Å–ª–∏ –¥–æ—Å—Ç–∏–≥–Ω—É—Ç –ø—Ä–µ–¥–µ–ª, —Å–±—Ä–∞—Å—ã–≤–∞–µ–º window_size –Ω–∞ —Å–ª–µ–¥—É—é—â–∏–π –¥–µ–Ω—å
                    if config["window_size"] >= 1500:
                        config["window_size"] = 1000
                        print("üîÅ –°–±—Ä–æ—Å window_size –¥–æ 500 –Ω–∞ —Å–ª–µ–¥—É—é—â–∏–π –¥–µ–Ω—å")

                    continue  # –≤–µ—Ä–Ω—ë–º—Å—è –≤ –æ—Å–Ω–æ–≤–Ω–æ–π while
                else:
                    print("üîÅ –ü–µ—Ä–µ–∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –æ–±—É—á–∞—é—â–µ–≥–æ –æ–∫–Ω–∞...")
                    df_train = load_initial_train_data(
                        symbol=config["symbol"],
                        window_size=config["window_size"],
                        start_timestamp=config["first_ts"],
                        interval=interval,
                    )
                    df_train_raw, df_val_raw = split_train_val(df_train)

        if config.get("best_params") is None:
            print("‚ö†Ô∏è best_params –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç ‚Äî –ø—Ä–æ–ø—É—Å–∫ –¥–Ω—è.")
            df_train = update_training_window(df_train, df_test, config["step_candles"])
            continue

        df_test_prepared = prepare_test_data(df_train, df_test, config["best_params"])
        if df_test_prepared is None:
            print("‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–¥–≥–æ—Ç–æ–≤–∫–µ —Ç–µ—Å—Ç–æ–≤–æ–≥–æ –æ–∫–Ω–∞ ‚Äî –ø—Ä–æ–ø—É—Å–∫ –¥–Ω—è.")
            df_train = update_training_window(df_train, df_test, config["step_candles"])
            continue

        config["risk_pct"] = calculate_inverse_balance_risk(config["balance"], config["initial_balance"])

        result, config["balance"], config["open_position"] = run_evaluation(
            df_test_prepared, symbol, config["balance"],
            config["risk_pct"], open_position=config.get("open_position")
        )

        if config["balance"] < 500:
            plot_backtest_progress(config["trade_log"], title="–ò—Å—Ç–æ—Ä–∏—è –ø–æ—Ä–∞–∂–µ–Ω–∏—è")
            return

        triggered_restart = False
        if should_trigger_restart(result, config):
            print("üîÅ –£—Å–ª–æ–≤–∏—è –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞ –º–æ–¥–µ–ª–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω—ã")
            triggered_restart = True
            reoptimize_strategy(config, df_train_raw, df_val_raw, symbol)
            config["no_trade_windows"] = 0

        update_tracking(config, interval, result, df_test, df_test_prepared, triggered_restart)
        df_train = update_training_window(df_train, df_test, config["step_candles"])

    finalize_walkforward(config)
