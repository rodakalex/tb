from datetime import datetime, timezone
import json
import pandas as pd

from strategy.utils_hashing import hash_dataframe
from trading_analysis.db import get_first_candle_from_db, load_ohlcv_from_db, save_model_run
from trading_analysis.feature_selection import select_important_features
from trading_analysis.indicators import calculate_indicators_cached
from trading_analysis.risk import calculate_inverse_balance_risk
from trading_analysis.signals import generate_signals_cached
from trading_analysis.backtest import run_backtest
from trading_analysis.charts import plot_backtest_progress

from strategy.objective import estimate_window_size_from_params, optimize_with_validation
from strategy.search_space import search_space
from trading_analysis.utils import prepare_params_for_logging, sanitize_params, split_train_val

def initialize_test(symbol: str, interval: str = "30") -> dict:
    """
    –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ—Ç –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –¥–ª—è walk-forward —Ç–µ—Å—Ç–∞.
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ª–æ–≤–∞—Ä—å —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏, –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–º–∏ –¥–ª—è –æ—Å–Ω–æ–≤–Ω–æ–≥–æ —Ü–∏–∫–ª–∞.
    """
    step_candles = int(24 * 60 / int(interval))
    ms_per_candle = int(interval) * 60_000
    last_candle = get_first_candle_from_db(symbol, interval)
    first_ts = int(last_candle.timestamp.timestamp() * 1000)
    now_ts = int(datetime.now(timezone.utc).timestamp() * 1000)

    return {
        "symbol": symbol,
        "interval": interval,
        "window_size": 2000,
        "step_candles": step_candles,
        "ms_per_candle": ms_per_candle,
        "first_ts": first_ts,
        "now_ts": now_ts,
        "total_pnl": 0.0,
        "days_elapsed": 0,
        "trade_log": [],
        "initial_balance": 1000.0,
        "balance": 1000.0,
        "best_params": None,
        "win_streak": 0,
        "risk_history": [],
        "search_space": search_space,
        "open_position": None,
    }

def load_initial_train_data(symbol: str, window_size: int, start_timestamp: int, interval: str):
    """
    –ó–∞–≥—Ä—É–∂–∞–µ—Ç –Ω–∞—á–∞–ª—å–Ω—ã–µ –æ–±—É—á–∞—é—â–∏–µ –¥–∞–Ω–Ω—ã–µ –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø–æ —Å–∏–º–≤–æ–ª—É.

    :param symbol: –ù–∞–∑–≤–∞–Ω–∏–µ –º–æ–Ω–µ—Ç—ã, –Ω–∞–ø—Ä–∏–º–µ—Ä 'BTCUSDT'
    :param window_size: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–≤–µ—á–µ–π –≤ –æ–±—É—á–∞—é—â–µ–º –æ–∫–Ω–µ
    :param start_timestamp: –ú–µ—Ç–∫–∞ –≤—Ä–µ–º–µ–Ω–∏ –Ω–∞—á–∞–ª–∞ (–≤ –º–∏–ª–ª–∏—Å–µ–∫—É–Ω–¥–∞—Ö)
    :return: DataFrame —Å –¥–∞–Ω–Ω—ã–º–∏
    """
    df = load_ohlcv_from_db(
        symbol=symbol,
        limit=window_size,
        start_timestamp=start_timestamp,
        interval=interval
    )
    return df

def is_end_of_data(test_end_ts: int) -> bool:
    """
    –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –¥–æ—Å—Ç–∏–≥–ª–∏ –ª–∏ –∫–æ–Ω—Ü–∞ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö.

    :param test_end_ts: –ö–æ–Ω–µ—Ü —Ç–µ—Å—Ç–æ–≤–æ–≥–æ –æ–∫–Ω–∞ –≤ –º–∏–ª–ª–∏—Å–µ–∫—É–Ω–¥–∞—Ö
    :return: True, –µ—Å–ª–∏ –±–æ–ª—å—à–µ –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
    """
    now_ts = int(datetime.now(timezone.utc).timestamp() * 1000)
    
    return test_end_ts > now_ts

def calculate_test_range(df_train, ms_per_candle, step_candles):
    """
    –í—ã—á–∏—Å–ª—è–µ—Ç –Ω–∞—á–∞–ª–æ –∏ –∫–æ–Ω–µ—Ü —Ç–µ—Å—Ç–æ–≤–æ–≥–æ –æ–∫–Ω–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ df_train.

    :param df_train: DataFrame —Å –∏—Å—Ç–æ—Ä–∏–µ–π –¥–ª—è –æ–±—É—á–µ–Ω–∏—è
    :param ms_per_candle: –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –æ–¥–Ω–æ–π —Å–≤–µ—á–∏ –≤ –º–∏–ª–ª–∏—Å–µ–∫—É–Ω–¥–∞—Ö
    :param step_candles: –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–≤–µ—á–µ–π –≤ —Ç–µ—Å—Ç–æ–≤–æ–º –æ–∫–Ω–µ
    :return: (test_start_ts, test_end_ts) ‚Äî –≤—Ä–µ–º–µ–Ω–Ω—ã–µ –º–µ—Ç–∫–∏ –Ω–∞—á–∞–ª–∞ –∏ –∫–æ–Ω—Ü–∞ —Ç–µ—Å—Ç–∞
    """
    last_ts_train = int(df_train.index[-1].timestamp() * 1000)
    test_start_ts = last_ts_train + ms_per_candle
    test_end_ts = test_start_ts + step_candles * ms_per_candle

    return test_start_ts, test_end_ts

def load_test_window_from_db(symbol: str, interval: str, test_range: tuple) -> pd.DataFrame:
    """
    –ó–∞–≥—Ä—É–∂–∞–µ—Ç —Ç–µ—Å—Ç–æ–≤–æ–µ –æ–∫–Ω–æ —Å–≤–µ—á–µ–π –∏–∑ –ª–æ–∫–∞–ª—å–Ω–æ–π –ë–î.

    :param symbol: —Ç–∏–∫–µ—Ä, –Ω–∞–ø—Ä–∏–º–µ—Ä "PRIMEUSDT"
    :param interval: —Å—Ç—Ä–æ–∫–∞ —Å –∏–Ω—Ç–µ—Ä–≤–∞–ª–æ–º, –Ω–∞–ø—Ä–∏–º–µ—Ä "30"
    :param test_range: –∫–æ—Ä—Ç–µ–∂ (start_timestamp_ms, end_timestamp_ms)
    :return: DataFrame —Å–æ —Å–≤–µ—á–∞–º–∏ –∑–∞ —É–∫–∞–∑–∞–Ω–Ω—ã–π –¥–∏–∞–ø–∞–∑–æ–Ω
    """
    start_ts, end_ts = test_range
    df = load_ohlcv_from_db(symbol, interval=interval, start_timestamp=start_ts, end_timestamp=end_ts)

    if df.empty:
        print("‚ö† –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –∏–∑ –ë–î –¥–ª—è —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ —Ç–µ—Å—Ç–æ–≤–æ–≥–æ –¥–∏–∞–ø–∞–∑–æ–Ω–∞.")
        return None

    return df

def prepare_test_data(df_train: pd.DataFrame, df_test: pd.DataFrame, best_params: dict) -> pd.DataFrame:
    """
    –û–±—ä–µ–¥–∏–Ω—è–µ—Ç —Ç—Ä–µ–Ω–∏—Ä–æ–≤–æ—á–Ω—ã–µ –∏ —Ç–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ, –ø—Ä–∏–º–µ–Ω—è–µ—Ç –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã –∏ —Å–∏–≥–Ω–∞–ª—ã,
    –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø–æ–¥–≥–æ—Ç–æ–≤–ª–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ —Ç–æ–ª—å–∫–æ –¥–ª—è —Ç–µ—Å—Ç–æ–≤–æ–≥–æ –æ–∫–Ω–∞.
    """
    df_full = pd.concat([df_train, df_test])
    sanitized_params = sanitize_params(best_params)

    # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Ö—ç—à–∏
    df_hash = hash_dataframe(df_full)
    params_serialized = json.dumps(sanitized_params, sort_keys=True)

    # –í—ã–∑—ã–≤–∞–µ–º –∫—ç—à-—Ñ—É–Ω–∫—Ü–∏–∏
    df_full = calculate_indicators_cached(df_hash, df_full, sanitized_params)
    df_full = generate_signals_cached(df_full, params_serialized)

    # üîç –û—Ç–±–æ—Ä –ø—Ä–∏–∑–Ω–∞–∫–æ–≤ —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω —Ä–∞–∑, –µ—Å–ª–∏ –∏—Ö –µ—â—ë –Ω–µ—Ç
    if "enabled_long_signals" not in best_params or "enabled_short_signals" not in best_params:
        print("üß† –û—Ç–±–∏—Ä–∞–µ–º –≤–∞–∂–Ω—ã–µ –ø—Ä–∏–∑–Ω–∞–∫–∏ —Å mutual_info_classif...")
        
        # Long
        feature_cols_long = [
            col for col in df_full.columns
            if col.startswith("long_") and "_score" not in col and "_entry" not in col
        ]
        important_feats_long, _ = select_important_features(df_full, feature_cols_long, target_col="long_entry")
        best_params["enabled_long_signals"] = important_feats_long
        print("üìå –í–∞–∂–Ω—ã–µ long –ø—Ä–∏–∑–Ω–∞–∫–∏:", important_feats_long)

        # Short
        feature_cols_short = [
            col for col in df_full.columns
            if col.startswith("short_") and "_score" not in col and "_entry" not in col
        ]
        important_feats_short, _ = select_important_features(df_full, feature_cols_short, target_col="short_entry")
        best_params["enabled_short_signals"] = important_feats_short
        print("üìå –í–∞–∂–Ω—ã–µ short –ø—Ä–∏–∑–Ω–∞–∫–∏:", important_feats_short)

    return df_full.iloc[-len(df_test):]

def run_evaluation(df_test_prepared, symbol: str, current_balance: float, risk_pct: float, open_position: dict = None) -> tuple:
    """
    –ü—Ä–æ–≤–æ–¥–∏—Ç –±—ç–∫—Ç–µ—Å—Ç –Ω–∞ —Ç–µ—Å—Ç–æ–≤–æ–º –æ–∫–Ω–µ –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç –∏ –æ–±–Ω–æ–≤–ª—ë–Ω–Ω—ã–π –±–∞–ª–∞–Ω—Å.

    :param df_test_prepared: DataFrame —Å —Ç–µ—Å—Ç–æ–≤—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏ –∏ —Å–∏–≥–Ω–∞–ª–∞–º–∏
    :param symbol: —Ç–∏–∫–µ—Ä —Å–∏–º–≤–æ–ª–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, "PRIMEUSDT")
    :param current_balance: —Ç–µ–∫—É—â–∏–π –±–∞–ª–∞–Ω—Å –Ω–∞ –º–æ–º–µ–Ω—Ç –≤—Ö–æ–¥–∞ –≤ –ø–µ—Ä–∏–æ–¥
    :param risk_pct: —Ä–∏—Å–∫ –Ω–∞ —Å–¥–µ–ª–∫—É –≤ –¥–æ–ª—è—Ö (–Ω–∞–ø—Ä–∏–º–µ—Ä, 0.05 = 5%)
    :return: (—Ä–µ–∑—É–ª—å—Ç–∞—Ç –±—ç–∫—Ç–µ—Å—Ç–∞, –Ω–æ–≤—ã–π –±–∞–ª–∞–Ω—Å)
    """
    result, final_state = run_backtest(
        df_test_prepared,
        symbol=symbol,
        report=True,
        finalize=False,
        initial_balance=current_balance,
        leverage=1,
        risk_pct=risk_pct,
        open_position=open_position
    )

    if final_state["position_type"]:
        new_open_position = {
            "position_type": final_state["position_type"],
            "entry_price": final_state["entry_price"],
            "position_size": final_state["position"],
            "trades": final_state["trades"]
        }
    else:
        new_open_position = None

    new_balance = current_balance + result["pnl"]
    return result, new_balance, new_open_position

def update_tracking(config: dict, interval, result: dict, df_test, df_test_prepared):
    """
    –û–±–Ω–æ–≤–ª—è–µ—Ç –∂—É—Ä–Ω–∞–ª —Ç—Ä–µ–π–¥–æ–≤, —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –º–æ–¥–µ–ª–∏ –∏ –º–µ—Ç—Ä–∏–∫–∏.

    :param config: –∫–æ–Ω—Ñ–∏–≥ —Å–ª–æ–≤–∞—Ä—å —Å–æ –≤—Å–µ–º —Ç–µ–∫—É—â–∏–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ–º
    :param result: —Ä–µ–∑—É–ª—å—Ç–∞—Ç –±—ç–∫—Ç–µ—Å—Ç–∞
    :param df_test: –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π DataFrame —Ç–µ—Å—Ç–∞ (–±–µ–∑ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤)
    :param df_test_prepared: –ø–æ–¥–≥–æ—Ç–æ–≤–ª–µ–Ω–Ω—ã–π DataFrame —Ç–µ—Å—Ç–∞ (—Å –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞–º–∏)
    """
    trade_log = config["trade_log"]
    symbol = config["symbol"]
    risk_pct = config["risk_pct"]
    best_params = config["best_params"]
    balance = config["balance"]
    retrained = result.get("pnl", 0) <= 0
    days_elapsed = config.get("days_elapsed", 0) + 1

    test_date = df_test_prepared.index[0].to_pydatetime()

    trade_log.append({
        "date": test_date.strftime("%Y-%m-%d"),
        "pnl": result["pnl"]
    })
    params_clean = prepare_params_for_logging(config["best_params"], config)
    save_model_run(
        symbol=symbol,
        interval=interval,
        date=test_date,
        params=params_clean,
        loss=-result["winrate"],
        pnl=result["pnl"],
        total_trades=result["total_trades"],
        winrate=result["winrate"],
        risk_pct=risk_pct,
        retrained=retrained
    )

    config["trade_log"] = trade_log
    config["days_elapsed"] = days_elapsed

def update_training_window(df_train, df_test, step_candles):
    """
    –û–±–Ω–æ–≤–ª—è–µ—Ç –æ–±—É—á–∞—é—â–µ–µ –æ–∫–Ω–æ, –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É—è –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–µ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π —Å df_test.
    """
    print("üß™ –¢–µ–∫—É—â–∏–π –∫–æ–Ω–µ—Ü df_train:", df_train.index[-1])
    print("üß™ –ù–∞—á–∞–ª–æ df_test:", df_test.index[0])

    base_cols = ["open", "high", "low", "close", "volume"]
    df_test_clean = df_test[base_cols]

    # –£–¥–∞–ª—è–µ–º –≤—Å–µ —Å—Ç—Ä–æ–∫–∏ –≤ df_train, –∫–æ—Ç–æ—Ä—ã–µ –ø–µ—Ä–µ–∫—Ä—ã–≤–∞—é—Ç—Å—è –ø–æ –≤—Ä–µ–º–µ–Ω–∏ —Å df_test
    df_train_filtered = df_train[df_train.index < df_test.index[0]]

    df_train_updated = pd.concat([df_train_filtered, df_test_clean])

    return df_train_updated


def finalize_walkforward(config):
    """
    –ó–∞–≤–µ—Ä—à–∞–µ—Ç walk-forward —Ç–µ—Å—Ç:
    - —Å—Ç—Ä–æ–∏—Ç —Ñ–∏–Ω–∞–ª—å–Ω—ã–π –≥—Ä–∞—Ñ–∏–∫ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞;
    - —Ä–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç –∏—Ç–æ–≥–æ–≤—É—é –¥–æ—Ö–æ–¥–Ω–æ—Å—Ç—å –∏ APR;
    - –≤—ã–≤–æ–¥–∏—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ —Ä–∏—Å–∫—É.
    """
    trade_log = config["trade_log"]
    initial_balance = config["initial_balance"]
    balance = config["balance"]
    days_elapsed = config["days_elapsed"]
    risk_history = config["risk_history"]
    symbol = config["symbol"]

    if not trade_log:
        print("‚ùó –ù–µ—Ç —Å–¥–µ–ª–æ–∫ ‚Äî –Ω–µ—Ç –≥—Ä–∞—Ñ–∏–∫–∞ –∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏.")
        return

    plot_backtest_progress(trade_log, title=f"–ü—Ä–æ–≥—Ä–µ—Å—Å —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –ø–æ {symbol}")

    total_pnl = balance - initial_balance
    apr = ((balance / initial_balance) ** (365 / days_elapsed) - 1) * 100 if days_elapsed > 0 else 0

    print(f"\nüìä –ò—Ç–æ–≥–æ–≤–∞—è –¥–æ—Ö–æ–¥–Ω–æ—Å—Ç—å: {total_pnl:.2f} | APR: {apr:.2f}% –∑–∞ {days_elapsed} –¥–Ω–µ–π")

    if risk_history:
        print("\nüìà –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ —Ä–∏—Å–∫—É:")
        print(f"- –°—Ä–µ–¥–Ω–∏–π —Ä–∏—Å–∫: {sum(risk_history) / len(risk_history):.3f}")
        print(f"- –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∏—Å–∫: {max(risk_history):.3f}")
        print(f"- –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —Ä–∏—Å–∫: {min(risk_history):.3f}")

def get_next_test_window(df_train, config, symbol, interval):
    test_range = calculate_test_range(df_train, config["ms_per_candle"], config["step_candles"])
    test_end_ts = test_range[1]
    if is_end_of_data(test_end_ts):
        return test_range, None

    df_test = load_test_window_from_db(symbol, interval, test_range)
    if df_test is None or df_test.empty:
        print("‚ö† –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Ç–µ—Å—Ç–æ–≤—ã—Ö –¥–∞–Ω–Ω—ã—Ö –≤ –ë–î.")
        return test_range, None

    return test_range, df_test

def initialize_best_params(config, df_train_raw, df_val_raw):
    df_full = pd.concat([df_train_raw, df_val_raw])
    df_hash = hash_dataframe(df_full)
    dummy_params = {}

    df_full = calculate_indicators_cached(df_hash, df_full, dummy_params)
    df_full = generate_signals_cached(df_full, json.dumps(dummy_params))

    feature_cols_long = [col for col in df_full.columns if col.startswith("long_") and "_score" not in col and "_entry" not in col]
    feature_cols_short = [col for col in df_full.columns if col.startswith("short_") and "_score" not in col and "_entry" not in col]

    important_feats_long, _ = select_important_features(df_full, feature_cols_long, target_col="long_entry")
    important_feats_short, _ = select_important_features(df_full, feature_cols_short, target_col="short_entry")

    print("\nüìå –û—Ç–æ–±—Ä–∞–Ω–Ω—ã–µ –ø—Ä–∏–∑–Ω–∞–∫–∏ (long):", important_feats_long)
    print("üìå –û—Ç–æ–±—Ä–∞–Ω–Ω—ã–µ –ø—Ä–∏–∑–Ω–∞–∫–∏ (short):", important_feats_short)

    best_params, sharpe_train, sharpe_val = optimize_with_validation(
        df_train_raw, df_val_raw, config["symbol"], search_space,
        initial_params=None,
        enabled_long_signals=important_feats_long,
        enabled_short_signals=important_feats_short
    )

    if not best_params:
        print("‚ö† –ü—Ä–æ–ø—É—Å–∫ –¥–Ω—è ‚Äî —Å—Ç—Ä–∞—Ç–µ–≥–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.")
        return False

    config.update({
        "best_params": best_params,
        "sharpe_train": sharpe_train,
        "sharpe_val": sharpe_val
    })
    return True

def try_prepare_test_data(df_train, df_test, config):
    try:
        return prepare_test_data(df_train, df_test, config["best_params"])
    except Exception as e:
        print(f"‚ö† –ü—Ä–æ–ø—É—Å–∫ –¥–Ω—è ‚Äî –æ—à–∏–±–∫–∞ –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∏ –¥–∞–Ω–Ω—ã—Ö: {e}")
        return None

def update_window_size(config):
    new_window = estimate_window_size_from_params(config["best_params"], verbose=True)

    if config["sharpe_train"] - config["sharpe_val"] > 1.0:
        print("‚ö†Ô∏è –ü–µ—Ä–µ–æ–±—É—á–µ–Ω–∏–µ: window_size –Ω–µ –æ–±–Ω–æ–≤–ª—è–µ–º")
        new_window = config["window_size"]

    max_jump = int(config["window_size"] * 0.3)
    if abs(new_window - config["window_size"]) > max_jump:
        print("‚ö†Ô∏è –†–µ–∑–∫–∏–π —Å–∫–∞—á–æ–∫ window_size ‚Äî –æ—Ç–º–µ–Ω—ë–Ω")
        new_window = config["window_size"]

    alpha = 0.3
    config["window_size"] = int((1 - alpha) * config["window_size"] + alpha * new_window)
    print(f"üìê –ù–æ–≤—ã–π window_size: {config['window_size']}")

def reoptimize_strategy(config, df_train_raw, df_val_raw, symbol):
    print("üîÅ –ü–µ—Ä–µ–æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –∏–∑-–∑–∞ —Å–µ—Ä–∏–∏ —É–±—ã—Ç–æ—á–Ω—ã—Ö –¥–Ω–µ–π.")
    best_params, sharpe_train, sharpe_val = optimize_with_validation(
        df_train_raw, df_val_raw, symbol, search_space,
        initial_params=config["best_params"],
        enabled_long_signals=config["best_params"]["enabled_long_signals"],
        enabled_short_signals=config["best_params"]["enabled_short_signals"]
    )

    if not best_params:
        print("‚ö† –ü–µ—Ä–µ–æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –Ω–µ –¥–∞–ª–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ ‚Äî best_params —Å–±—Ä–æ—à–µ–Ω—ã.")
        config["best_params"] = None
    else:
        config.update({
            "best_params": best_params,
            "sharpe_train": sharpe_train,
            "sharpe_val": sharpe_val
        })

def should_trigger_restart(result, config) -> bool:
    if result["final_balance"] < config["initial_balance"] * 0.9:
        return True

    if result["max_loss_streak"] >= 3:
        return True

    if result["total_trades"] == 0:
        config["no_trade_windows"] = config.get("no_trade_windows", 0) + 1
        if config["no_trade_windows"] >= 2:
            return True
    else:
        config["no_trade_windows"] = 0  # —Å–±—Ä–æ—Å, –µ—Å–ª–∏ —Å–¥–µ–ª–∫–∏ –ø–æ—è–≤–∏–ª–∏—Å—å

    if result["winrate"] < 0.4:
        return True

    return False

def walk_forward_test(symbol="PRIMEUSDT", interval="30"):
    config = initialize_test(symbol, interval)
    df_train = load_initial_train_data(
        symbol=symbol,
        window_size=config["window_size"],
        start_timestamp=config["first_ts"],
        interval=interval,
    )

    while True:
        test_range, df_test = get_next_test_window(df_train, config, symbol, interval)
        if df_test is None:
            break

        df_train_raw, df_val_raw = split_train_val(df_train)

        if not config.get("best_params"):
            success = initialize_best_params(config, df_train_raw, df_val_raw)
            if not success:
                df_train = update_training_window(df_train, df_test, config["step_candles"])
                continue

        df_test_prepared = try_prepare_test_data(df_train, df_test, config)
        if df_test_prepared is None:
            df_train = update_training_window(df_train, df_test, config["step_candles"])
            continue

        update_window_size(config)
        config["risk_pct"] = calculate_inverse_balance_risk(config["balance"], config["initial_balance"])

        result, config["balance"], config["open_position"] = run_evaluation(df_test_prepared, symbol, config["balance"], config["risk_pct"], open_position=config.get("open_position"))
        update_tracking(config, interval, result, df_test, df_test_prepared)

        if config["balance"] < 500:
            plot_backtest_progress(config["trade_log"], title="–ò—Å—Ç–æ—Ä–∏—è –ø–æ—Ä–∞–∂–µ–Ω–∏—è")
            return

        if should_trigger_restart(result, config):
            print("üîÅ –£—Å–ª–æ–≤–∏—è –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞ –º–æ–¥–µ–ª–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω—ã")
            reoptimize_strategy(config, df_train_raw, df_val_raw, symbol)
            config["no_trade_windows"] = 0  # —Å–±—Ä–æ—Å —Å—á—ë—Ç—á–∏–∫–∞

        df_train = update_training_window(df_train, df_test, config["step_candles"])

    finalize_walkforward(config)
